import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { FileUpload } from '@/components/ui/file-upload';
import { useAuthStore } from '@/lib/store/auth-store';
import { toast } from 'sonner';

interface BackgroundUploadDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: (backgroundUrl: string) => void;
}

export function BackgroundUploadDialog({ open, onOpenChange, onSuccess }: BackgroundUploadDialogProps) {
  const [fileUrl, setFileUrl] = useState('');
  const [uploading, setUploading] = useState(false);
  const [saving, setSaving] = useState(false);
  const { token, user, forceRefreshUserProfile } = useAuthStore();
  const [localToken, setLocalToken] = useState<string | null>(null);

  // 当对话框打开时，尝试从localStorage获取最新token
  useEffect(() => {
    if (open) {
      // 尝试强制刷新用户资料，确保token是最新的
      forceRefreshUserProfile();
      
      try {
        // 直接从localStorage获取最新的token
        const authStorage = localStorage.getItem('auth-storage');
        if (authStorage) {
          const { state } = JSON.parse(authStorage);
          if (state?.token) {
            const freshToken = state.token.startsWith('Bearer ') ? state.token : `Bearer ${state.token}`;
            setLocalToken(freshToken);
            console.log('从localStorage获取到token:', freshToken.substring(0, 15) + '...');
          }
        }
      } catch (error) {
        console.error('获取localStorage中的token失败:', error);
      }
    }
  }, [open, forceRefreshUserProfile]);

  const getAuthToken = (): string | null => {
    // 首先使用localToken（从localStorage直接获取的最新token）
    if (localToken) {
      return localToken;
    }
    
    // 其次使用store中的token
    if (token) {
      return token.startsWith('Bearer ') ? token : `Bearer ${token}`;
    }
    
    // 最后尝试从localStorage再次获取
    try {
      const authStorage = localStorage.getItem('auth-storage');
      if (authStorage) {
        const { state } = JSON.parse(authStorage);
        if (state?.token) {
          return state.token.startsWith('Bearer ') ? state.token : `Bearer ${state.token}`;
        }
      }
    } catch (error) {
      console.error('获取localStorage中的token失败:', error);
    }
    
    return null;
  };

  const handleUpload = async (files: File[]) => {
    const currentToken = getAuthToken();
    
    if (!currentToken) {
      toast.error('请先登录');
      return [{ url: '', key: '' }];
    }
    
    const file = files[0];
    if (!file) return [{ url: '', key: '' }];
    
    // 文件大小检查 (最大10MB)
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      toast.error('文件大小不能超过 10MB');
      return [{ url: '', key: '' }];
    }
    
    setUploading(true);
    const formData = new FormData();
    formData.append('file', file);
    formData.append('folder', 'creators/backgrounds');
    
    try {
      console.log('上传背景图片，使用token:', currentToken.substring(0, 15) + '...');
      
      const response = await fetch('/api/storage/upload', {
        method: 'POST',
        body: formData,
        headers: {
          'Authorization': currentToken,
        },
        cache: 'no-cache',
      });
      
      if (!response.ok) {
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          errorData = { error: '服务器响应错误' };
        }
        toast.error(errorData.error || '上传失败');
        return [{ url: '', key: '' }];
      }
      
      const result = await response.json();
      setFileUrl(result.url);
      toast.success('上传成功');
      return [result];
    } catch (error) {
      console.error('Upload error:', error);
      toast.error('上传失败，请重试');
      return [{ url: '', key: '' }];
    } finally {
      setUploading(false);
    }
  };

  const handleConfirm = async () => {
    if (!fileUrl || !user) {
      toast.error('请先上传背景图片');
      return;
    }

    setSaving(true);
    try {
      // 添加调试信息
      console.log('准备更新背景图片，用户信息:', {
        userId: user.id,
        userIdType: typeof user.id,
        nickname: user.nickname,
        hasAvatar: !!user.avatarUrl
      });

      // 获取最新token
      const currentToken = getAuthToken();
      
      if (!currentToken) {
        toast.error('认证失败，请重新登录');
        return;
      }

      console.log('保存背景图片，使用token:', currentToken.substring(0, 15) + '...');

      // 构建一个简化的payload，只包含必要的字段
      // 确保userId为数字类型
      const userId = typeof user.id === 'string' ? parseInt(user.id, 10) : user.id;
      
      if (isNaN(userId)) {
        throw new Error('用户ID无效');
      }
      
      // 构建请求数据，确保所有字段符合DTO要求
      const payload = {
        userId: userId, // 确保是数字类型
        nickname: user.nickname || '未命名用户', // nickname是必填字段
        backgroundUrl: fileUrl, // 上传的新背景图片URL
        // 添加其他必要字段的默认值
        avatarUrl: user.avatarUrl || '',
        bio: '',
        expertise: '',
        images: [],
        videos: [],
        audios: []
      };

      console.log('最终发送的数据:', {
        userId: payload.userId,
        userIdType: typeof payload.userId,
        nickname: payload.nickname,
        backgroundUrl: payload.backgroundUrl?.substring(0, 30) + '...'
      });

      // 更新背景图片
      console.log('准备发送POST请求到 /api/creators');
      const updateResponse = await fetch('/api/creators', {
        method: 'POST',
        headers: {
          'Authorization': currentToken,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload),
        cache: 'no-cache',
      });

      console.log('API响应状态:', updateResponse.status, updateResponse.statusText);

      if (!updateResponse.ok) {
        let errorText;
        try {
          const errorContent = await updateResponse.text();
          console.log('错误响应内容:', errorContent);
          
          try {
            // 尝试解析JSON
            if (errorContent && errorContent.trim()) {
              const errorData = JSON.parse(errorContent);
              console.log('解析后的错误数据:', errorData);
              
              if (errorData.details) {
                errorText = errorData.details;
              } else if (errorData.message) {
                errorText = errorData.message;
              } else if (errorData.error) {
                errorText = errorData.error;
              } else {
                errorText = JSON.stringify(errorData);
              }
            } else {
              errorText = `保存失败 (HTTP ${updateResponse.status})`;
            }
          } catch (parseError) {
            console.error('解析错误JSON失败:', parseError);
            errorText = errorContent || `保存失败 (HTTP ${updateResponse.status})`;
          }
        } catch (e) {
          console.error('获取错误响应内容失败:', e);
          errorText = `保存失败 (HTTP ${updateResponse.status})`;
        }
        
        console.error('保存背景图片失败，详细错误:', {
          status: updateResponse.status,
          errorText: errorText
        });
        
        throw new Error(errorText);
      }

      toast.success('背景图片保存成功');
      if (onSuccess) {
        onSuccess(fileUrl);
      }
      setFileUrl('');
      onOpenChange(false);
    } catch (error: any) {
      console.error('保存背景图片失败:', error);
      
      // 处理错误对象
      let errorMessage = '保存背景图片失败';
      if (error) {
        if (typeof error === 'string') {
          errorMessage = error;
        } else if (error instanceof Error) {
          errorMessage = error.message || errorMessage;
        } else if (typeof error === 'object') {
          try {
            errorMessage = JSON.stringify(error);
          } catch (e) {
            console.error('错误对象无法转换为字符串:', e);
          }
        }
      }
      
      console.log('最终显示的错误信息:', errorMessage);
      toast.error(errorMessage);
    } finally {
      setSaving(false);
    }
  };

  const resetForm = () => {
    setFileUrl('');
  };

  return (
    <Dialog open={open} onOpenChange={(open) => {
      if (!open) resetForm();
      onOpenChange(open);
    }}>
      <DialogContent className="max-w-lg max-h-[90vh] overflow-hidden flex flex-col">
        <DialogHeader className="flex-shrink-0">
          <DialogTitle className="text-xl font-semibold text-primary-gradient">
            上传背景图片
          </DialogTitle>
        </DialogHeader>
        
        <div className="flex-1 overflow-y-auto space-y-6 pr-2">
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <div className="flex items-start gap-3">
              <div className="w-5 h-5 bg-blue-500 rounded-full flex items-center justify-center mt-0.5">
                <svg className="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                  <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                </svg>
              </div>
              <div>
                <h4 className="font-medium text-blue-900 mb-1">建议图片尺寸</h4>
                <ul className="text-sm text-blue-700 space-y-1">
                  <li>• 推荐尺寸：1920x400 像素</li>
                  <li>• 最小尺寸：1200x300 像素</li>
                  <li>• 宽高比：约 4.8:1 或 16:3</li>
                  <li>• 文件大小：不超过 10MB</li>
                  <li>• 支持格式：JPG、PNG、WebP</li>
                </ul>
              </div>
            </div>
          </div>

          <div className="border-2 border-dashed border-gray-200 rounded-xl p-6 hover:border-[var(--custom-primary)] transition-colors">
            <FileUpload
              onUpload={handleUpload}
              onUrlsChange={urls => setFileUrl(urls[0] || '')}
              accept={{ 'image/*': ['.png', '.jpg', '.jpeg', '.webp'] }}
              maxFiles={1}
              maxSize={10 * 1024 * 1024}
              placeholder="拖拽背景图片到此处或点击上传（最大10MB）"
            />
          </div>
          
          {fileUrl && (
            <div className="p-4 bg-gradient-to-r from-green-50 to-emerald-50 border border-green-200 rounded-xl">
              <div className="flex items-center gap-2 mb-3">
                <div className="w-5 h-5 bg-green-500 rounded-full flex items-center justify-center">
                  <svg className="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                </div>
                <p className="text-sm font-medium text-green-700">上传成功</p>
              </div>
              <div className="rounded-lg overflow-hidden">
                <img src={fileUrl} alt="背景预览" className="w-full h-24 object-cover" />
              </div>
            </div>
          )}
        </div>
        
        <DialogFooter className="pt-6 flex-shrink-0 border-t border-gray-100 mt-4">
          <Button 
            variant="outline" 
            onClick={() => onOpenChange(false)}
            className="px-6"
          >
            取消
          </Button>
          <Button
            disabled={!fileUrl || uploading || saving}
            onClick={handleConfirm}
            className="bg-primary-gradient text-white border-0 px-6 hover:opacity-90 transition-opacity"
          >
            {uploading ? '上传中...' : saving ? '保存中...' : '确定'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
} 